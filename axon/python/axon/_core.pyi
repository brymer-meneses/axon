from collections.abc import Sequence
import enum

from numpy.typing import ArrayLike
from typing import Any, Tuple, TypeAlias

class dtype(enum.Enum):
    float32 = 0
    float64 = 1

float32: dtype = dtype.float32
float64: dtype = dtype.float64

class LoweringLevel(enum.Enum):
    Axon = 0
    Standard = 1
    Linalg = 2
    Loops = 3
    LLVM = 4

Axon: LoweringLevel = LoweringLevel.Axon
Standard: LoweringLevel = LoweringLevel.Standard
Linalg: LoweringLevel = LoweringLevel.Linalg
Loops: LoweringLevel = LoweringLevel.Loops
LLVM: LoweringLevel = LoweringLevel.LLVM

Shape: TypeAlias = Tuple[int, ...]

class CompilationUnit:
    def dump_ir(self) -> str: ...
    def execute(self, arg: Sequence[Tensor], /) -> None: ...

class Tensor:
    @property
    def shape(self) -> Shape: ...
    @property
    def requires_grad(self) -> bool: ...
    def __repr__(self) -> str: ...
    def __add__(self, arg: Tensor, /) -> Tensor: ...
    def __mul__(self, arg: Tensor, /) -> Tensor: ...
    def __matmul__(self, arg: Tensor, /) -> Tensor: ...
    def backward(self) -> None: ...
    @property
    def grad(self) -> Tensor: ...

class Graph:
    def __init__(self) -> None: ...
    def compile(self, arg: LoweringLevel, /) -> CompilationUnit: ...
    def create_constant(self, arg0: ArrayLike, arg1: dtype, /) -> Tensor: ...
    def trace(self, arg: Tensor, /) -> None: ...
    def untrace(self, arg: Tensor, /) -> None: ...

def _set_current_graph(graph: Graph) -> None: ...
def _create_tensor(array: ArrayLike, requires_grad: bool, dtype: dtype) -> Tensor: ...
def _create_filled(
    shape: Shape, value: Any, requires_grad: bool, dtype: dtype
) -> Tensor: ...
def _create_randn(array: Shape, requires_grad: bool, dtype: dtype) -> Tensor: ...
